#  持续集成和构建
如今软件开发不再是少数人的活动了，Dev光杆司令的时代已经不再，曾经流行了一段时间的神庙逃亡也是又一对夫妇开发的。或许你会说，微服务的天下即将到来，一个资深的架构师将系统拆分成足够多足够细粒度的微服务，每个微服务小到可以由一个人去开发完成，这还需要集成吗？需要！因为这样众多的微服务虽然都是独立的小个体，但它们的集成将是所面临的一大挑战，所以CI将能够更快地给你提供反馈，让你知道你负责的微服务是否跟其它的微服务是否还良好合作着。

好处:
1. 减少重复的过程
2. 降低风险
3. 可视化
4. 增强团队的信心
5. 随时随地可以生成可部署的软件（CD）


## 持续集成(CI)
### 开发流程
*Code(编码)* -> *Build(构建)* -> *Integrate(集成)* -> *Test(测试)*

持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。


### 功能
+ **全面的自动化测试：**这是实践持续集成&持续部署的基础，同时，选择合适的自动化测试工具也极其重要；
+ **灵活的基础设施：**容器，虚拟机的存在让开发人员和 QA 人员不必再大费周折；
+ **版本控制工具：**Git, SVN, CVS...
+ **自动化的构建和软件发布流程的工具：**Jenkins, Buildbot, Travis CI, Strider, Go, Integrity...
+ **反馈机制：**如构建/测试的失败，可以快速地反馈到相关负责人，以尽快解决达到一个更稳定的版本。

### 优点
* 减少风险：一天中进行多次的集成，并做了相应的测试，这样有利于检查缺陷，了解软件的健康状况，减少假定。
* 快速发现错误：每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。
* 防止分支大幅偏离主干：如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。
* 减少重复过程：可以将重复的编译、集成、测试、审查、部署等动作都变成自动化的，无需太多人工干预，让人们的时间更多的投入到动脑筋的、更高价值的事情上。
* 增强项目的可见性：让我们能够注意到趋势并进行有效的决策。
* 建立团队对开发产品的信心：因为他们清楚的知道每一次构建的结果，他们知道他们对软件的改动造成了哪些影响，结果怎么样。
* 让产品可以快速迭代，同时还保持高质量。


![ci](./continuous_integration.png)

## 持续交付
### 工作流程
*Code(编码)* -> *Build(构建)* -> *Integrate(集成)* -> *Test(测试)* -> *Delivery(交付)*

持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。  

持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。  

![cd](./continuous_integration.png)

### 优点
* 快速发布。能够应对业务需求，并更快地实现软件价值。
* 编码->测试->上线->交付的频繁迭代周期缩短，同时获得迅速反馈；
* 高质量的软件发布标准。整个交付过程标准化、可重复、可靠，
* 整个交付过程进度可视化，方便团队人员了解项目成熟度；
* 更先进的团队协作方式。从需求分析、产品的用户体验到交互 设计、开发、测试、运维等角色密切协作，相比于传统的瀑布式软件团队，更少浪费。


## 持续部署
### 工作流程
*Code(编码)* -> *Build(构建)* -> *Integrate(集成)*-> *Test(测试)* -> *Delivery(交付)* -> *Deployment(部署)*


持续部署（Continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。  

持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。  

持续部署的前提是能自动化完成测试、构建、部署等步骤。它与持续交付的区别，可以参考下图。  

![cd](./continuous_integration.png)

### 优点
持续部署主要好处是，可以相对独立地部署新的功能，并能快速地收集真实用户的反馈。


## 整体流程  

根据持续集成的设计，代码从提交到生产，整个过程有以下几步。  

### 提交  
流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。  

### 测试（第一轮）  
代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。
测试有好几种。  


    - 单元测试：针对函数或模块的测试  
    - 集成测试：针对整体产品的某个功能的测试，又称功能测试  
    - 端对端测试：从用户界面直达数据库的全链路测试  

第一轮至少要跑单元测试。  

### 构建  
通过第一轮测试，代码就可以合并进主干，就算可以交付了。  

交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。  

常用的构建工具如下。  

    - [Jenkins](http://jenkins-ci.org/)   
    - [Travis](https://travis-ci.com/)  


Jenkins和Strider是开源软件，Travis和Codeship对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。  

### 测试（第二轮）  
构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。  

第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。  

需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。  

### 部署
通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。  

生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有Ansible，Chef，Puppet等。  

### 回滚  
一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。  


## 参考链接
- [Continuous Integration](https://www.martinfowler.com/articles/continuousIntegration.html) 
- [The Product Managers’ Guide to Continuous Delivery and DevOps](http://www.mindtheproduct.com/2016/02/what-the-hell-are-ci-cd-and-devops-a-cheatsheet-for-the-rest-of-us/)
