title: makefile简单指南
＝＝＝＝＝＝


# 介绍
本文将首先介绍为什么要将你的Ｃ源代码分离成几个合理的独立档案，什么时候需要分，
怎么才能分的好。然后将会告诉你 GNU Make 怎样使你的编译和连接步骤自动化。

## 多文件项目

### 为什么使用它们?

首先，多文件项目的好处在那里呢？它们看起来把事情弄的复杂无比。又要header 文件
，又要`extern`声明，而且如果需要查找一个文件，你要在更多的文件里搜索。

但其实我们有很有力的理由支持我们把一个项目分解成小块。当你改 动一行代码，编译
器需要全部重新编译来生成一个新的可执行文件。 但如果你的项目是分开在几个小文件
里，当你改动其中一个文件的时候，别的源文件的目标文件(object files)已经存在，所
以没有什么原因去重新编译它们。你所需要做的只是重现编译被改动过的那个文件，然后
重新连接所有的目标文件罢了。在大型的项目中，这意味着从很长的(几分钟到几小时）
重新编译缩短为十几，二十几秒的简单调整。

只要通过基本的规划，将一个项目分解成多个小文件可使你更加容易的找到一段代码。很
简单，你根据代码的作用把你的代码分解到不同的文件里。当你要看一段代码时，你可以
准确的知道在那个文件中去寻找它。

从很多目标文件生成一个程序包比从一个单一的大目标文件生成要好的多。当然实际上这
是否真是一个优势则是由你所用的系统来决定的。但是当使用 gcc/ld 把一个程序包连接
到一个程序时，在连接的过程中，它会尝试不去连接没有使用到的部分。但它每次只能从
程序包中把一个完整的目标文件排除在外。因此如果你参考一个程序包中某一个目标档中
任何一个符号的话， 那么这个目标文件整个都会被连接进来。要是一个程序包被非常充
分的分解了的话，那么经连接后，得到的可执行文件会比从一个大目标文件组成的程序包
连接得到的文件小得多。

又因为你的程序是很模块化的，文件之间的共享部分被减到最少，那就有很多好处——可以
很容易的追踪到臭虫，这些模块经常是可以用在其它的项目里的，同时别人也可以更容易
的理解你的一段代码是干什么的。当然此外还有许多别的好处

### 何时分解你的项目

如果你需要开发一个相当大的项目，在开始前，应该考虑一下你将如何实现它，并且生成
几个文件来放你的代码。当然，在你的项目开发的过程中，你可以建立新的文件，但如果
你这么做的话，说明你可能改变了当初的想法，你应该想想是否需要对整体结构也进行相
应的调整。

对于中型的项目，你当然也可以采用上述技巧，但你也可以就那么开始输入你的代码，当
你的码多到难以管理的时候再把它们分解成不同的档案。但以我的经验来说，开始时在脑
子里形成一个大概的方案， 并且尽量遵从它，或在开发过程中，随着程序的需要而修改
，会使开 发变得更加容易。

### 怎样分解项目
- 不要用一个 header 文件指向多个源码文件。用一个header定义一个源码文件的方式会
  更有效，也更容易查寻。
- 如果可以的话，完全可以用超过一个的header 文件来指向同一个源码文件。有时将不
  可公开调用的函数原型，类型定义等等，从它们的Ｃ源码文件中分离出来是非常有用的
  。使用一个 header 文件装公开符号，用另一个装私人符号意味着如果 你改变了这个
  源码文件的内部结构，你可以只是重新编译它而 不需要重新编译那些使用它的公开
  header 文件的其它的源文 件。

- 不要在多个 header 文件中重复定义信息。 如果需要， 在其中一个 header 文件里
  #include 另一个，但是不要重复输入相同的 header 信息两次。
- 在每一个源码文件里， #include 那些声明了源码文件中的符号的所有 header 文件。

### 对于常见错误的注释
1. 定义符 (Identifier) 在源码文件中的矛盾：在Ｃ里，变量和函数的缺省状态是公用
   的。因此，任何Ｃ源码档案都可以引用存在于其它源码档中的通用函数和通用变量，
   既使这个档案没有那个变量或函数的声明或原型。因此你必须保证在不同的两个档案
   里不能 用同一个符号名称，否则会有连接错误或者在编译时会有警告。

一种避免这种错误的方法是在公用的符号前加上跟其所在源文件有关的前缀。比如：所有
在 gfx.c 里的函数都加上前缀"gfx"。

要防止一个符号在它被定义的源文件以外被看到，可在它的定义前 加上关键字“static”
。这对只在一个档案内部使用，其它档案都 都不会用到的简单函数是很有用的。 

2. 多次定义的符号： header档会被逐字的替换到你源文件里#include 的位置的。因此
   ，如果header档被`#include`到一个以上的源文件里，这个header档中所有的定义就
   会出现在每一个有关的源码文件里。这会使它们里的符号被定义一次以上，从而出现
   连接错误（见 上）。

解决方法：不要在header 档里定义变量。你只需要在`header`档里声明它们然后在适当
的Ｃ源码文件里定义它们。对于初学者来说，定义和声明是很容易混淆的。声明的作用是
告诉编译器其所声明的符号应该存在， 并且要有所指定的类型。但是，它并不会使编译
器分配贮存空间。 而定义的做用是要求编译器分配贮存空间。当做一个声明而不是做 定
义的时候，在声明前放一个关键字“extern”。

函数原型里隐含着 extern 的意思，所以不需顾虑这个问题。

3. 重复定义，重复声明，矛盾类型：解决的方法是要确定每一个header 档在任一个源码
   文件中只被包含了一次。我们一般是用预处理器来达到这个目的。当我们进入每一个
   header档时，我们为这个header档`#define` 一个巨集指令。只有在这个巨集指令没
   有被定义的前提下，我们才真正使用该header档的主体。在实际应用上，我们只要简
   单在文件头或尾加入如下定义：

```c
#ifndef FILENAME_H
#define FILENAME_H
```

然后把下面一行码放在最后：

```c
#endif
```

建议在所有的 header 档中都加入这样的定义。

### 重新编译一个多文件项目

清楚的区别编译和连接是很重要的。编译器使用源码文件来产生某种形式的目标文件。在
这个过程中，外部的符号参考并没有被解释或替换。然后我们使用连接器来连接这些目标
文件和一些 标准的程序包再加你指定的程序包，最后连接生成一个可执行程序。 在这个
阶段，一个目标文件中对别的文件中的符号的参考被解释，并 报告不能被解释的参考，
一般是以错误信息的形式报告出来。

基本的步骤就应该是，把你的源码文件一个一个的编译成目标文件的格式，最后把所有的
目标文件加上需要的程序包连接成一个可执行文件。 具体怎么做是由你的编译器决定的
。这里我只给出gcc的有关命令。


一般来说，如果你只给它Ｃ源码文件，它将预处理，编译，组合所有的文件，然后把所得
的目标文件连接成一个可执行文件(一般生成的 文件被命名为 a.out ）。你当然可以这
么做，但这会破坏很多我们把一个项目分解成多个文件所得到的好处。

如果你给它一个 -c 开关，gcc 只把给它的文件编译成目标文件，用源码文件的文件名命
名, 但后缀由`.c`或`.cc`变成`.o`。 如果你给它的是一列目标文件， gcc 会把它们连
接成可执行文件， 缺省文件名是 a.out 。你可以改变缺省名，用开关 -o 后跟你指定
的文件名。

因此，当你改变了一个源码文件后，你需要重新编译它： `gcc -c filename.c` 然后重
新连接项目：`gcc -o exec_filename *.o`。如果你改变了一个header 档，你需要重新
编译所有 #include 过 这个档的源码文件，你可以用 `gcc -c file1.c file2.c
file3.c` 然后象上边一样连接。

当然这么做是很繁琐的，GNU Make 工具可以帮我们解决这个问题。


# GNU Make 工具
## 基本 makefile 结构
GNU Make 的主要工作是读进一个文本文件， makefile 。这个文件里主要是有关哪些文
件（`target`目的文件）是从哪些别的文件（‘dependencies’依靠文件）中产生的，用什
么命令来进行 这个产生过程。有了这些信息， make会检查磁碟上的文件，如果目的文件
的时间戳比至少它的一个依靠文件旧的话，make 就执行相应的命令，以便更新目的文件
。

makefile 一般被叫做“makefile”或“Makefile”。当然你可以 在 make 的命令行指定别的
文件名。如果你不特别指定，它会寻找`makefile`或`Makefile`，因此使用这两个名字是
最简单 的。

一个 makefile 主要含有一系列的规则，如下：

```makefile
: ...
(tab)<command>
(tab)<command>
...
```

例如，考虑以下的 makefile ：

```makfile
myprog : foo.o bar.o
  gcc foo.o bar.o -o myprog

foo.o : foo.c foo.h bar.h
  gcc -c foo.c -o foo.o

bar.o : bar.c bar.h
  gcc -c bar.c -o bar.o
```

这是一个非常基本的makefile , make 从最上面开始，把上面第一个目的，‘myprog’，做
为它的主要目标。给出的规则说明只要文件‘myprog’ 比文件‘foo.o’或‘bar.o’中的任何
一个旧，下一行的命令将会被执行。

但是，在检查文件 foo.o 和 bar.o 的时间戳之前，它会往下查 找那些把 foo.o 或
bar.o 做为目标文件的规则。它找到的关于 foo.o 的规则，该文件的依靠文件是 foo.c,
foo.h 和 bar.h 。 它从下面再找不到生成这些依靠文件的规则，它就开始检查磁碟 上
这些依靠文件的时间戳。如果这些文件中任何一个的时间戳比 foo.o 的新，命令 'gcc
-o foo.o foo.c' 将会执行，从而更新 文件 foo.o 。 

接下来对文件 bar.o 做类似的检查，依靠文件在这里是文件 bar.c 和 bar.h 。

现在，make 回到‘myprog’的规则。如果刚才两个规则中的任 何一个被执行，myprog 就
需要重建（因为其中一个 .o 档就会比 ‘myprog’新），因此连接命令将被执行。

希望到此，你可以看出使用make 工具来建立程序的好处, 前一章中所有繁琐的检查步骤
都由 make 替你做了：检查时间戳。 你的源码文件里一个简单改变都会造成那个文件被
重新编译（因 为 .o 文件依靠 .c 文件），进而可执行文件被重新连接（因为 .o 文件
被改变了）。其实真正的得益是在当你改变一个 header 档的时候——你不再需要记住那个
源码文件依靠它，因为所有的资料都在makefile 里。 make会很轻松的替你重新编译所有
那些因依靠这个 header 文件而改变了的源码文件，如有需要，再进行重新连接。

当然，你要确定你在makefile中所写的规则是正确无误的，只列出那些在源码文件中
被#include的header 档……

## 编写`make`规则 (Rules)

最明显的（也是最简单的）编写规则的方法是一个一个的查 看源码文件，把它们的目标
文件做为目的，而Ｃ源码文件和被它 #include 的 header 档做为依靠文件。但是你也要
把其它被这些 header 档 #include 的 header 档也列为依靠文件，还有那些被 包括的
文件所包括的文件……然后你会发现要对越来越多的文件 进行管理，然后你的头发开始脱
落，你的脾气开始变坏，你的脸 色变成菜色，你走在路上开始跟电线杆子碰撞，终于你
捣毁你的 电脑显示器，停止编程。到低有没有些容易点儿的方法呢？

当然有！向编译器要！在编译每一个源码文件的时候，它实在应 该知道应该包括什么样
的 header 档。使用 gcc 的时候，用 -M 开关，它会为每一个你给它的Ｃ文件输出一个
规则，把目标文件 做为目的，而这个Ｃ文件和所有应该被 #include 的 header 文 件将
做为依靠文件。注意这个规则会加入所有 header 文件，包 括被角括号(`<', `>')和双
引号(`"')所包围的文件。其实我们可以 相当肯定系统 header 档（比如 stdio.h,
stdlib.h 等等）不会 被我们更改，如果你用 -MM 来代替 -M 传递给 gcc，那些用角括
号包围的 header 档将不会被包括。（这会节省一些编译时间）

由 gcc 输出的规则不会含有命令部分；你可以自己写入你的命令 或者什么也不写，而让
make 使用它的隐含的规则（参考下面的 2.4 节）。

## Makefile 变量

上面提到 makefiles 里主要包含一些规则。它们包含的其它的东 西是变量定义。

makefile 里的变量就像一个环境变量(environment variable)。 事实上，环境变量在
make 过程中被解释成 make 的变量。这些 变量是大小写敏感的，一般使用大写字母。它
们可以从几乎任何 地方被引用，也可以被用来做很多事情，比如：
- 贮存一个文件名列表。在上面的例子里，生成可执行文件的 规则包含一些目标文件名
  做为依靠。在这个规则的命令行 里同样的那些文件被输送给 gcc 做为命令参数。如果
  在这 里使用一个变数来贮存所有的目标文件名，加入新的目标 文件会变的简单而且较
  不易出错。

- 贮存可执行文件名。如果你的项目被用在一个非 gcc 的系 统里，或者如果你想使用一
  个不同的编译器，你必须将所 有使用编译器的地方改成用新的编译器名。但是如果使
  用一 个变量来代替编译器名，那么你只需要改变一个地方，其 它所有地方的命令名就
  都改变了。

- 贮存编译器旗标。假设你想给你所有的编译命令传递一组 相同的选项（例如 -Wall -O
  -g）；如果你把这组选项存 入一个变量，那么你可以把这个变量放在所有呼叫编译器
  的地方。而当你要改变选项的时候，你只需在一个地方改 变这个变量的内容。要设定
  一个变量，你只要在一行的开始写下这个变量的名字，后 面跟一个 = 号，后面跟你要
  设定的这个变量的值。以后你要引用 这个变量，写一个 $ 符号，后面是围在括号里的
  变量名。比如在 下面，我们把前面的 makefile 利用变量重写一遍：

```makefile
OBJS = foo.o bar.o
CC = gcc
CFLAGS = -Wall -O -g

myprog : $(OBJS)
  $(CC) $(OBJS) -o myprog

foo.o : foo.c foo.h bar.h
  $(CC) $(CFLAGS) -c foo.c -o foo.o

bar.o : bar.c bar.h
  $(CC) $(CFLAGS) -c bar.c -o bar.o
```

还有一些设定好的内部变量，它们根据每一个规则内容定义。三个 比较有用的变量是
$@, $< 和 $^ （这些变量不需要括号括住）。 $@ 扩展成当前规则的目的文件名， $<
扩展成依靠列表中的第 一个依靠文件，而 $^ 扩展成整个依靠的列表（除掉了里面所有
重 复的文件名）。利用这些变量，我们可以把上面的 makefile 写成：

```makefile
OBJS = foo.o bar.o
CC = gcc
CFLAGS = -Wall -O -g

myprog : $(OBJS)
  $(CC) $^ -o $@

foo.o : foo.c foo.h bar.h
  $(CC) $(CFLAGS) -c $< -o $@

bar.o : bar.c bar.h
  $(CC) $(CFLAGS) -c $< -o $@
```

你可以用变量做许多其它的事情，特别是当你把它们和函数混合 使用的时候。如果需要
更进一步的了解，请参考 GNU Make 手册。 ('man make', 'man makefile')

## 隐含规则 (Implicit Rules)

请注意，在上面的例子里，几个产生 .o 文件的命令都是一样的。 都是从 .c 文件和相
关文件里产生 .o 文件，这是一个标准的步 骤。其实 make 已经知道怎么做——它有一些
叫做隐含规则的内 置的规则，这些规则告诉它当你没有给出某些命令的时候，应该 怎么
办。

如果你把生成 foo.o 和 bar.o 的命令从它们的规则中删除， make 将会查找它的隐含规
则，然后会找到一个适当的命令。它的命令会 使用一些变量，因此你可以按照你的想法
来设定它：它使用变量 CC 做为编译器（象我们在前面的例子），并且传递变量 CFLAGS
（给 C 编译器，C++ 编译器用 CXXFLAGS ），CPPFLAGS （ C 预 处理器旗标），
TARGET_ARCH （现在不用考虑这个），然后它加 入旗标 '-c' ，后面跟变量 $< （第一
个依靠名），然后是旗 标 '-o' 跟变量 $@ （目的文件名）。一个Ｃ编译的具体命令将
会是：

$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c $< -o $@

当然你可以按照你自己的需要来定义这些变量。这就是为什么用 gcc 的 -M 或 -MM 开关
输出的码可以直接用在一个 makefile 里。

## 假象目的 (Phony Targets)

假设你的一个项目最后需要产生两个可执行文件。你的主要目标 是产生两个可执行文件
，但这两个文件是相互独立的——如果一 个文件需要重建，并不影响另一个。你可以使用
假象目的来 达到这种效果。一个假象目的跟一个正常的目的几乎是一样的， 只是这个目
的文件是不存在的。因此， make 总是会假设它需要 被生成，当把它的依赖文件更新后
，就会执行它的规则里的命令行。

如果在我们的makefile开始处输入：

```makefile
all : exec1 exec2
```

其中 exec1 和 exec2 是我们做为目的的两个可执行文件。 make 把这个 'all' 做为它
的主要目的，每次执行时都会尝试把 'all' 更新。但既然这行规则里没有哪个命令来作
用在一个叫 'all' 的 实际文件（事实上 all 并不会在磁碟上实际产生），所以这个规
则并不真的改变 'all' 的状态。可既然这个文件并不存在，所以 make 会尝试更新 all
规则，因此就检查它的依靠 exec1, exec2 是否需要更新，如果需要，就把它们更新，从
而达到我们的目的。 

假象目的也可以用来描述一组非预设的动作。例如，你想把所有由 make 产生的文件删除
，你可以在 makefile 里设立这样一个规则：

```makefile
veryclean :
  rm *.o
  rm myprog
```

前提是没有其它的规则依靠这个 'veryclean' 目的，它将永远 不会被执行。但是，如果
你明确的使用命令 'make veryclean' ， make 会把这个目的做为它的主要目标，执行那
些 rm 命令。

如果你的磁碟上存在一个叫 veryclean 文件，会发生什么事？这 时因为在这个规则里没
有任何依靠文件，所以这个目的文件一定是 最新的了（所有的依靠文件都已经是最新的
了），所以既使用户明 确命令 make 重新产生它，也不会有任何事情发生。解决方法是
标 明所有的假象目的（用 .PHONY），这就告诉 make 不用检查它们 是否存在于磁碟上
，也不用查找任何隐含规则，直接假设指定的目 的需要被更新。在 makefile 里加入下
面这行包含上面规则的规则：

```makefile
.PHONY : veryclean
```

就可以了。注意，这是一个特殊的 make 规则，make 知道 .PHONY 是一个特殊目的，当
然你可以在它的依靠里加入你想用的任何假象 目的，而 make 知道它们都是假象目的。

## 函数 (Functions)

makefile 里的函数跟它的变量很相似——使用的时候，你用一个 $ 符号跟开括号，函数名
，空格后跟一列由逗号分隔的参数，最后 用关括号结束。例如，在 GNU Make 里有一个
叫 'wildcard' 的函 数，它有一个参数，功能是展开成一列所有符合由其参数描述的文
件名，文件间以空格间隔。你可以像下面所示使用这个命令：

```makefile
SOURCES = $(wildcard *.c)
```

这行会产生一个所有以 '.c' 结尾的文件的列表，然后存入变量 SOURCES 里。当然你不
需要一定要把结果存入一个变量。

另一个有用的函数是 patsubst （ patten substitude, 匹配替 换的缩写）函数。它需
要３个参数——第一个是一个需要匹配的 式样，第二个表示用什么来替换它，第三个是一
个需要被处理的 由空格分隔的字列。例如，处理那个经过上面定义后的变量，

OBJS = $(patsubst %.c,%.o,$(SOURCES))

    这行将处理所有在 SOURCES 字列中的字（一列文件名），如果它的 结尾是 '.c' ，
    就用 '.o' 把 '.c' 取代。注意这里的 % 符号将匹 配一个或多个字符，而它每次所
    匹配的字串叫做一个‘柄’(stem) 。 在第二个参数里， % 被解读成用第一参数所匹
    配的那个柄。

## 一个比较有效的 makefile

利用我们现在所学的，我们可以建立一个相当有效的 makefile 。 这个 makefile 可以
完成大部分我们需要的依靠检查，不用做太大 的改变就可直接用在大多数的项目里。

首先我们需要一个基本的 makefile 来建我们的程序。我们可以让 它搜索当前目录，找
到源码文件，并且假设它们都是属于我们的项 目的，放进一个叫 SOURCES 的变量。这里
如果也包含所有的 `*.cc` 文件，也许会更保险，因为源码文件可能是 C++ 码的。

```makefile
SOURCES = $(wildcard *.c *.cc)
```

利用 patsubst ，我们可以由源码文件名产生目标文件名，我们需 要编译出这些目标文
件。如果我们的源码文件既有 .c 文件，也有 .cc 文件，我们需要使用相嵌的 patsubst
函数呼叫：

```makefile
OBJS = $(patsubst %.c,%.o,$(patsubst %.cc,%.o,$(SOURCES)))
```

最里面一层 patsubst 的呼叫会对 .cc 文件进行后缀替代，产生的结 果被外层的
patsubst 呼叫处理，进行对 .c 文件后缀的替代。

现在我们可以设立一个规则来建可执行文件：

```makefile
myprog : $(OBJS)
  gcc -o myprog $(OBJS)
```

进一步的规则不一定需要， gcc 已经知道怎么去生成目标文件 (object files) 。下面
我们可以设定产生依靠信息的规则：

```makefile
depends : $(SOURCES)
  gcc -M $(SOURCES) > depends
```

在这里如果一个叫 'depends' 的文件不存在，或任何一个源码文件 比一个已存在的
depends 文件新，那么一个 depends 文件会被生 成。depends 文件将会含有由 gcc 产
生的关于源码文件的规则（注 意 -M 开关）。现在我们要让 make 把这些规则当做
makefile 档 的一部分。这里使用的技巧很像 C 语言中的 #include 系统——我 们要求
make 把这个文件 include 到 makefile 里，如下：

```makefile
include depends
```

GNU Make看到这个，检查`depend`目的是否更新了，如果没有它用我们给它的命令重新产
生 depends档。然后它会把这组新规则包含进来，继续处理最终目标 'myprog' 。当看到
有关 myprog 的规则，它会检查所有的目标文件是否更新——利用 depends 文件 里的规则
，当然这些规则现在已经是更新过的了。

这个系统其实效率很低，因为每当一个源码文件被改动，所有的源码 文件都要被预处理
以产生一个新的 'depends' 文件。而且它也不是100% 的安全，这是因为当一个header档
被改动，依靠信息并不会被更新。但就基本工作来说，它也算相当有用的了。


# 总结
GNU Make 是一件强大的工具，虽然它主要是用来建立程序，它还有很多别的用处。如果
想要知道更多有关这个工具的知识，它的句法, 函数和许多别的特点, 你应该参看它的参
考文件 (info pages, 别的GNU 工具也一样，看它们的info pages. )。

